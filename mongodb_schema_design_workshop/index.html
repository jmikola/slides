<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>MongoDB Schema Design Workshop</title>
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <link rel="stylesheet" href="../vendor/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="../vendor/highlight.js/src/styles/github.css">
        <link rel="stylesheet" href="../common/css/theme/10gen.css">
        <link rel="stylesheet" href="css/main.css">
        <link rel="stylesheet" href="../vendor/reveal.js/css/print/pdf.css" type="text/css" media="print">

        <!--[if lt IE 9]>
        <script src="../vendor/reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-state="title">
                    <h1><span class="logo-mongodb"></span> Schema Design Workshop</h1>

                    <p class="bio">Jeremy Mikola<br><a href="http://twitter.com/jmikola">@jmikola</a></p>
                </section>

                <section>
                    <section data-markdown>
                        # Agenda

                        1. Basic schema design principles for MongoDB
                        2. Schema design over an application's lifetime
                        3. Common design patterns
                        4. Sharding
                    </section>

                    <section data-markdown>
                        # Goals

                        * Learn the schema design process in MongoDB
                        * Practice applying common principles via exercises
                        * Understand the implications of sharding
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## What is a schema and why is it important?
                    </section>

                    <section data-markdown data-state="library" class="bg">
                        # Schema

                        * Map concepts and relationships to data
                        * Set expectations for the data
                        * Minimize overhead of iterative modifications
                        * Ensure compatibility
                    </section>

                    <section data-markdown data-state="normalize-denormalize">
                        ## Normalization

                        <div class="node-3">
                            <div class="node">
                                <span class="label">users</span>
                                <ul>
                                    <li><code>username</code></li>
                                    <li><code>first_name</code></li>
                                    <li><code>last_name</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&larr;</div>
                            <div class="node">
                                <span class="label">books</span>
                                <ul>
                                    <li><code>title</code></li>
                                    <li><code>isbn</code></li>
                                    <li><code>language</code></li>
                                    <li><code>created_by</code></li>
                                    <li><code>author</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&rarr;</div>
                            <div class="node">
                                <span class="label">authors</span>
                                <ul>
                                    <li><code>first_name</code></li>
                                    <li><code>last_name</code></li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section data-markdown data-state="normalize-denormalize">
                        ## Denormalization

                        <div class="node-3">
                            <div class="node">
                                <span class="label">users</span>
                                <ul>
                                    <li><code>username</code></li>
                                    <li><code>first_name</code></li>
                                    <li><code>last_name</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&larr;</div>
                            <div class="node">
                                <span class="label">books</span>
                                <ul>
                                    <li><code>title</code></li>
                                    <li><code>isbn</code></li>
                                    <li><code>language</code></li>
                                    <li><code>created_by</code></li>
                                    <li class="embedded-object">
                                        <code>author</code>
                                        <ul>
                                            <li><code>first_name</code></li>
                                            <li><code>last_name</code></li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## What is schema design like in MongoDB?

                        * Schema is defined at the application-level
                        * Design is part of each phase in its lifetime
                        * There is no magic formula
                    </section>

                    <section data-markdown class="ul-2col">
                        ## MongoDB Documents

                        Storage in BSON &rarr; <a href="http://bsonspec.org/">BSONSpec.org</a>

                        * Scalars
                            * Doubles
                            * Integers (32 or 64-bit)
                            * UTF-8 strings
                            * UTC Date, timestamp
                            * Binary, regex, code
                            * Object ID
                            * `null`
                        * Rich types
                            * Objects
                            * Arrays
                    </section>

                    <section data-markdown>
                        ## Terminology

<pre><code class="language-javascript">{
    "mongodb"    : "relational db",
    "database"   : "database",
    "collection" : "table",
    "document"   : "row",
    "field"      : "column",
    "index"      : "index",
    "sharding" : {
        "shard"     : "partition",
        "shard key" : "partition key"
    }
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Three Considerations in MongoDB Schema Design

                        1. The data your application needs
                        2. Your application's read usage of the data
                        3. Your application's write usage of the data
                    </section>
                </section>

                <section>
                    <section data-markdown data-state="library" class="bg">
                        # Case Study

                        ## Library Web Application

                        Different schemas are possible
                    </section>

                    <section data-markdown>
                        ## Author Schema

<pre><code class="language-javascript">{
    "_id": int,
    "first_name": string,
    "last_name": string
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## User Schema

<pre><code class="language-javascript">{
    "_id": int,
    "username": string,
    "password": string
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Book Schema

<pre><code class="language-javascript">{
    "_id": int,
    "title": string,
    "slug": string,
    "author": int,
    "available": boolean,
    "isbn": string,
    "pages": int,
    "publisher": {
        "city": string,
        "date": date,
        "name": string
    },
    "subjects": [ string, string ],
    "language": string,
    "reviews": [
       { "user": int, "text": string },
       { "user": int, "text": string }
    ],
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Example Documents
                    </section>

                    <section data-markdown>
                        ## Author Document

<pre><code class="language-javascript">&gt; db.authors.findOne()
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald"
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## User Document
<pre><code class="language-javascript">&gt; db.users.findOne()
{
    _id: 1,
    username: "emily@10gen.com",
    password: "slsjfk4odk84k209dlkdj90009283d"
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Book Document

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English",
    reviews: [
       { user: 1, text: "One of the best…" },
       { user: 2, text: "It's hard to…" }
    ]
}</code></pre>
                    </section>
               </section>

               <section>
                    <section data-markdown>
                        # Embedded Objects

                        #### AKA embedded or sub-documents

                        What advantages do they have?

                        When should they be used?
                    </section>

                    <section data-markdown>
                        ## Embedded Objects

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
<span class="code-highlight inline-block">    publisher: {
        name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        city: "London"
    },</span>
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English",
    reviews: [
       { user: 1, text: "One of the best…" },
       { user: 2, text: "It's hard to…" }
    ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Embedded Objects

                        * Great for read performance
                        * One seek to load the entire document
                        * One round trip to the database
                        * Writes can be slow if constantly adding to objects
                    </section>
               </section>

               <section>
                    <section data-markdown>
                        # Linked Documents

                        What advantages does this approach have?

                        When should they be used?
                    </section>

                    <section data-markdown>
                        ## Linked Documents

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
<span class="code-highlight inline-block">    author: 1,</span>
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English",
    reviews: [
       { <span class="code-highlight">user: 1</span>, text: "One of the best…" },
       { <span class="code-highlight">user: 2</span>, text: "It's hard to…" }
    ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Linked Documents

                        * More, smaller documents
                        * Can make queries by ID very simple
                        * Accessing linked document data requires extra read
                        * What effect does this have on the system?
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Data, RAM and Disk
                    </section>

                    <section>
                        <img src="img/memory-1.png" alt="memory-1.png">
                    </section>

                    <section>
                        <img src="img/memory-2.png" alt="memory-2.png">
                    </section>

                    <section>
                        <img src="img/memory-3.png" alt="memory-3.png">
                    </section>

                    <section>
                        <img src="img/memory-4.png" alt="memory-4.png">
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Arrays

                        When should they be used?
                    </section>

                    <section data-markdown>
                        ## Array of Scalars

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        city: "London"
    },
<span class="code-highlight inline-block">    subjects: ["Love stories", "1920s", "Jazz Age"],</span>
    language: "English",
    reviews: [
       { user: 1, text: "One of the best…" },
       { user: 2, text: "It's hard to…" }
    ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Array of Objects

<pre><code class="language-javascript">&gt; db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English",
<span class="code-highlight inline-block">    reviews: [
       { user: 1, text: "One of the best…" },
       { user: 2, text: "It's hard to…" }
    ],</span>
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown class="ul-2col">
                        ## Exercise #1

                        Design a schema for users and their book reviews

                        * Users
                            * username (string)
                            * email (string)
                        * Reviews
                            * text (string)
                            * rating (integer)
                            * created_at (date)

                        *Usernames are immutable*
                    </section>

                    <section data-markdown>
                        ### Exercise #1: Solution A

                        Reviews may be queried by user or book

<pre><code class="language-javascript">// db.users (one document per user)
{   _id: ObjectId("…"),
    username: "bob",
    email: "bob@example.com"
}</code></pre>

<pre><code class="language-javascript">// db.reviews (one document per review)
{   _id: ObjectId("…"),
    user: ObjectId("…"),
    book: ObjectId("…"),
    rating: 5,
    text: "This book is excellent!",
    created_at: ISODate("2012-10-10T21:14:07.096Z")
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #1: Solution B

                        Optimized to retrieve reviews by user

<pre><code class="language-javascript">// db.users (one document per user with all reviews)
{   _id: ObjectId("…"),
    username: "bob",
    email: "bob@example.com",
    reviews: [
        {   book: ObjectId("…"),
            rating: 5,
            text: "This book is excellent!",
            created_at: ISODate("2012-10-10T21:14:07.096Z")
        }
    ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #1: Solution C

                        Optimized to retrieve reviews by book

<pre><code class="language-javascript">// db.users (one document per user)
{   _id: ObjectId("…"),
    username: "bob",
    email: "bob@example.com"
}</code></pre>

<pre><code class="language-javascript">// db.books (one document per book with all reviews)
{   _id: ObjectId("…"),
    // Other book fields…
    reviews: [
        {   user: ObjectId("…"),
            rating: 5,
            text: "This book is excellent!",
            created_at: ISODate("2012-10-10T21:14:07.096Z")
        }
    ]
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Schema Design Over an Application's Lifetime

                        * Development
                        * Production
                        * Iterative Modifications
                    </section>
                 </section>

                <section>
                    <section data-markdown>
                        # Development Phase

                        Basic CRUD functionality
                    </section>
                 </section>

                 <section>
                    <section data-markdown>
                        # Create<span class="crud">RUD</span>

<pre><code class="language-javascript">author = {
    _id: 2,
    first_name: "Arthur",
    last_name: "Miller"
};

db.authors.insert(author);</code></pre>

                        * The `_id` field is unique and automatically indexed
                        * MongoDB will generate an [ObjectId](http://www.mongodb.org/display/DOCS/Object+IDs#ObjectIDs-BSONObjectIDSpecification) if not provided
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # <span class="crud">C</span>Read<span class="crud">UD</span>

<pre><code class="language-javascript">&gt; db.authors.find({ "last_name": "Miller" })
{
    _id: 2,
    first_name: "Arthur",
    last_name: "Miller"
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Reads and Indexing

                        Examine the query after creating an index.

<pre><code class="language-javascript">&gt; db.books.ensureIndex({ "slug": 1 })

&gt; db.books.find({ "slug": "the-great-gatsby" }).explain()
{
<span class="code-highlight inline-block">    "cursor": "BtreeCursor slug_1",</span>
    "isMultiKey" : false,
    "n" : 1,
    "nscannedObjects" : 1,
    "nscanned" : 1,
    "scanAndOrder" : false,
    "indexOnly" : false,
    "nYields" : 0,
    "nChunkSkips" : 0,
    "millis" : 0,
    // Other fields follow…
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Multi-key Indexes

                        Index all values in an array field.

<pre><code class="language-javascript">&gt; db.books.ensureIndex({ "subjects": 1 })</code></pre>
                     </section>

                    <section data-markdown>
                         ## Indexing Embedded Fields

                         Index an embedded object's field.

<pre><code class="language-javascript">&gt; db.books.ensureIndex({ "publisher.name": 1 })</code></pre>
                     </section>

                    <section data-markdown>
                        ## Query operators

                        * Conditional operators
                            * `$gt`, `$gte`, `$lt`, `$lte`, `$ne`, `$all`, `$in`, `$nin`, `$size`, `$and`, `$or`, `$nor`, `$mod`, `$type`, `$exists`
                        * Regular expressions
                        * Value in an array
                            * `$elemMatch`
                        * Cursor methods and modifiers
                            * `count()`, `limit()`, `skip()`, `snapshot()`, `sort()`, `batchSize()`, `explain()`, `hint()`
                    </section>
                 </section>

                 <section>
                    <section data-markdown>
                        # <span class="crud">CR</span>Update<span class="crud">D</span>

<pre><code class="language-javascript">review = {
    user: 1,
    text: "I did NOT like this book."
};

db.books.update(
    { _id: 1 },
    { $push: { reviews: review }}
);</code></pre>
                    </section>

                    <section data-markdown>
                        ## Atomic Modifiers

                        Update specific fields within a document

                        * `$set`, `$unset`
                        * `$push`, `$pushAll`
                        * `$addToSet`, `$pop`
                        * `$pull`, `$pullAll`
                        * `$rename`
                        * `$bit`
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # <span class="crud">CRU</span>Delete

<pre><code class="language-javascript">&gt; db.books.remove({ _id: 1 })</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Production Phase

                        Evolve schema to meet the application's read and write patterns
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Read Usage

                        Finding books by an author's first name

<pre><code class="language-javascript">authors = db.authors.find({ first_name: /^f.*/i }, { _id: 1 });

authorIds = authors.map(function(x) { return x._id; });

db.books.find({author: { $in: authorIds }});</code></pre>
                    </section>

                    <section data-markdown>
                        ## Read Usage

                        "Cache" the author name in an embedded document

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
<span class="code-highlight inline-block">    author: {
        first_name: "F. Scott",
        last_name: "Fitzgerald"
    }</span>
    // Other fields follow…
}</code></pre>

                        Queries are now one step

<pre><code class="language-javascript">&gt; db.books.find({ author.first_name: /^f.*/i })</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Write Usage

                        Users can review a book

<pre><code class="language-javascript">review = {
    user: 1,
    text: "I thought this book was great!",
    rating: 5
};

&gt; db.books.update(
    { _id: 3 },
    { $push: { reviews: review }}
);</code></pre>

                        * Document size limit (16MB)
                        * Storage fragmentation after many updates/deletes
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #2

                        * Display the 10 most recent reviews by a user
                        * Make efficient use of memory and disk seeks
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Store users' reviews in monthly buckets

<pre><code class="language-javascript">// db.reviews (one document per user per month)
{   _id: "bob-201210",
    reviews: [
        {   _id: ObjectId("…"),
            rating: 5,
            text: "This book is excellent!",
            created_at: ISODate("2012-10-10T21:14:07.096Z")
        },
        {   _id: ObjectId("…"),
            rating: 2,
            text: "I didn't really enjoy this book.",
            created_at: ISODate("2012-10-11T20:12:50.594Z")
        }
    ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Adding a new review to the appropriate bucket

<pre><code class="language-javascript">myReview = {
    _id: ObjectId("…"),
    rating: 3,
    text: "An average read.",
    created_at: ISODate("2012-10-13T12:26:11.502Z")
};

&gt; db.reviews.update(
      { _id: "bob-201210" },
      { $push: { reviews: myReview }}
);</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Display the 10 most recent reviews by a user

<pre><code class="language-javascript">cursor = db.reviews.find(
    { _id: /^bob-/ },
    { reviews: { $slice: 10 }}
).sort({ _id: -1 });

num = 0;

while (cursor.hasNext() &amp;&amp; num &lt; 10) {
    doc = cursor.next();

    for (var i = 0; i &lt; doc.reviews.length &amp;&amp; num &lt; 10; ++i, ++num) {
        printjson(doc.reviews[i]);
    }
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Deleting a review

<pre><code class="language-javascript">cursor = db.reviews.update(
    { _id: "bob-201210" },
    { $pull: { reviews: { _id: ObjectId("…") }}}
);</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Iterative Modifications

                        Schema design is evolutionary
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Allow users to browse by book subject

<pre><code class="language-javascript">&gt; db.subjects.findOne()
{
    _id: 1,
    name: "American Literature",
    sub_category: {
         name: "1920s",
         sub_category: { name: "Jazz Age" }
   }
}</code></pre>

                        * How can you search this collection?
                        * Be aware of document size limitations
                        * Benefit from hierarchy being in same document
                    </section>

                    <section data-markdown>
                        ## Tree Structures

<pre><code class="language-javascript">&gt; db.subjects.find()
{   _id: "American Literature" }

{   _id : "1920s",
    ancestors: ["American Literature"],
    parent: "American Literature"
}

{   _id: "Jazz Age",
    ancestors: ["American Literature", "1920s"],
    parent: "1920s"
}

{   _id: "Jazz Age in New York",
    ancestors: ["American Literature", "1920s", "Jazz Age"],
    parent: "Jazz Age"
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Tree Structures

                        Find sub-categories of a given subject

<pre><code class="language-javascript">&gt; db.subjects.find({ ancestors: "1920s" })
{
    _id: "Jazz Age",
    ancestors: ["American Literature", "1920s"],
    parent: "1920s"
}

{
    _id: "Jazz Age in New York",
    ancestors: ["American Literature", "1920s", "Jazz Age"],
    parent: "Jazz Age"
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #3

                        * Allow users to borrow library books
                            * User sends a loan request
                            * Library approves or not
                            * Requests time out after seven days
                        * Approval process is asynchronous
                        * Requests may be prioritized
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        * Need to maintain order and state
                        * Ensure that updates are atomic

<pre><code class="language-javascript">// Create a new loan request
db.loans.insert({
    _id: { borrower: "bob", book: ObjectId("…") },
    pending: false,
    approved: false,
    priority: 1,
});

// Find the highest priority request and mark as pending approval
request = db.loans.findAndModify({
<span class="code-highlight inline-block">    query: { pending: false },
    sort: { priority: -1 },</span>
    update: { $set: { pending: true, started: new ISODate() }},
    new: true
});</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        * Updated and added fields
                        * Modified document was returned

<pre><code class="language-javascript">{
    _id: { borrower: "bob", book: ObjectId("…") },
<span class="code-highlight inline-block">    pending: true,</span>
    approved: false,
    priority: 1,
<span class="code-highlight inline-block">    started: ISODate("2012-10-11T22:09:42.542Z")</span>
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

<pre><code class="language-javascript">// Library approves the loan request
db.loans.update(
    { _id: { borrower: "bob", book: ObjectId("…") }},
    { $set: { pending: false, approved: true }}
);</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

<pre><code class="language-javascript">// Request times out after seven days
limit = new Date();
limit.setDate(limit.getDate() - 7);

db.loans.update(
    { pending: true, started: { $lt: limit }},
    { $set: { pending: false, approved: false }}
);</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #4

                        Allow users to recommend books

                        * Users can recommend each book only once
                        * Display a book's current recommendations
                    </section>

                    <section data-markdown>
                        ### Exercise #4: Solution

<pre><code class="language-javascript">// db.recommendations (one document per user per book)
db.recommendations.insert({
    book: ObjectId("…"),
    user: ObjectId("…")
});

// Unique index ensures users can't recommend twice
db.recommendations.ensureIndex(
    { book: 1, user: 1 },
    { unique: true }
);

// Count the number of recommendations for a book
db.recommendations.count({ book: ObjectId("…") });</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #4: Solution

                        * Indexes in MongoDB are not counting
                        * Counts are computed via index scans
                        * Denormalize totals on books

<pre><code class="language-javascript">db.books.update(
    { _id: ObjectId("…") },
    { $inc: { recommendations: 1 }}
});</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Common Design Patterns
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # One-to-one Relationship

                        Let's pretend that authors only write one book.
                    </section>

                    <section data-markdown>
                        ## Linking

                        Either side, or both, can track the relationship.

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
<span class="code-highlight inline-block">    author: 1,</span>
    // Other fields follow…
}

&gt; db.authors.findOne({ _id: 1 })
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald"
<span class="code-highlight inline-block">    book: 1,</span>
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Embedded Object

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
<span class="code-highlight inline-block">    author: {
        first_name: "F. Scott",
        last_name: "Fitzgerald"
    }</span>
    // Other fields follow…
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # One-to-many Relationship

                        In reality, authors may write multiple books.
                    </section>

                    <section data-markdown>
                        ## Array of ID's

                        The "one" side tracks the relationship.

<pre><code class="language-javascript">&gt; db.authors.findOne()
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald",
<span class="code-highlight inline-block">    books: [1, 3, 20]</span>
}</code></pre>

                        * Flexible and space-efficient
                        * Additional query needed for non-ID lookups
                    </section>

                    <section data-markdown>
                        ## Single Field with ID

                        The "many" side tracks the relationship.

<pre><code class="language-javascript">&gt; db.books.find({ author: 1 })
{
    _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
<span class="code-highlight inline-block">    author: 1,</span>
    // Other fields follow…
}

{
    _id: 3,
    title: "This Side of Paradise",
    slug: "9780679447238-this-side-of-paradise",
<span class="code-highlight inline-block">    author: 1,</span>
    // Other fields follow…
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Array of Objects

<pre><code class="language-javascript">&gt; db.authors.findOne()
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald",
<span class="code-highlight inline-block">    books: [
        { _id: 1, title: "The Great Gatsby" },
        { _id: 3, title: "This Side of Paradise" }
    ]</span>
    // Other fields follow…
}</code></pre>

                        Use `$slice` operator to return a subset of books
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Many-to-many Relationship

                        Some books may also have co-authors.
                    </section>

                    <section data-markdown>
                        ## Array of ID's on Both Sides

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
<span class="code-highlight inline-block">    authors: [1, 5]</span>
    // Other fields follow…
}</code></pre>

<pre><code class="language-javascript">&gt; db.authors.findOne()
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald",
<span class="code-highlight inline-block">    books: [1, 3, 20]</span>
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Array of ID's on Both Sides

                        Query for all books by a given author

<pre><code class="language-javascript">db.books.find({ authors: 1 });</code></pre>

                        Query for all authors of a given book

<pre><code class="language-javascript">db.authors.find({ books: 1 });</code></pre>
                    </section>

                    <section data-markdown>
                        ## Array of ID's on One Side

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 1,
    title: "The Great Gatsby",
<span class="code-highlight inline-block">    authors: [1, 5]</span>
    // Other fields follow…
}</code></pre>

<pre><code class="language-javascript">&gt; db.authors.find({ _id: { $in: [1, 5] }})
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald"
}

{
    _id: 5,
    first_name: "Unknown",
    last_name: "Co-author"
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## Array of ID's on One Side

                        Query for all books by a given author

<pre><code class="language-javascript">db.books.find({ authors: 1 });</code></pre>

                        Query for all authors of a given book

<pre><code class="language-javascript">book = db.books.findOne(
    { title: "The Great Gatsby" },
    { authors: 1 }
);

db.authors.find({ _id: { $in: book.authors }});</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #5

                        * Tracking time series data
                            * Graph recommendations per unit of time
                            * Count by: day, hour, minute
                    </section>

                    <section data-markdown>
                        ### Exercise #5: Solution A

<pre><code class="language-javascript">// db.rec_ts (time series buckets, hour and minute sub-docs)
db.rec_ts.insert({
    book: ObjectId("…"),
    day: ISODate("2012-10-11T00:00:00.000Z")
    total: 0,
    hour:   { "0": 0, "1": 0, /* … */ "23": 0 },
    minute: { "0": 0, "1": 0, /* … */ "1439": 0 }
});

// Record a recommendation created one minute before midnight
db.rec_ts.update(
    { book: ObjectId("…"), day: ISODate("2012-10-11T00:00:00.000Z") },
    { $inc: { total: 1, "hour.23": 1, "minute.1439": 1 }}
});</code></pre>
                    </section>

                    <section data-markdown>
                        ## BSON Storage

                        * Sequence of key/value pairs
                        * Not a hash map
                        * Optimized to scan quickly

                        <br>
                        <div class="node-3">
                            <div class="node">
                                <span class="label">minute</span>
                                <small><code>[0] [1] … [1439]</code></small>
                            </div>
                        </div>

                        What is the cost of updating the minute before midnight?
                    </section>

                    <section data-markdown>
                        ## BSON Storage

                        We can skip sub-documents

                        <br>
                        <div class="node-3">
                            <div class="node">
                                <span class="label">hour<sub>0</sub></span>
                                <small><code>[0] [1] … [59]</code></small>
                            </div>
                            <div class="arrow">…</div>
                            <div class="node">
                                <span class="label">hour<sub>23</sub></span>
                                <small><code>[1380] … [1439]</code></small>
                            </div>
                        </div>

                        How could this change the schema?
                    </section>

                    <section data-markdown>
                        ### Exercise #5: Solution B

<pre><code class="language-javascript">// db.rec_ts (time series buckets, each hour a sub-doc)
db.rec_ts.insert({
    book: ObjectId("…"),
    day: ISODate("2012-10-11T00:00:00.000Z")
    total: 148,
    hour: {
        "0": { total: 7, "0": 0, /* … */ "59": 2 },
        "1": { total: 3, "60": 1, /* … */ "119": 0 },
        // Other hours…
        "23": { total: 12, "1380": 0, /* … */ "1439": 3 }
    }
});

// Record a recommendation created one minute before midnight
db.rec_ts.update(
    { book: ObjectId("…"), day: ISODate("2012-10-11T00:00:00.000Z") },
    { $inc: { total: 1, "hour.23.total": 1, "hour.23.1439": 1 }}
});</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Single-collection Inheritance

                        Take advantage of MongoDB's features

                        * Documents need not all have the same fields
                        * [Sparsely index](http://www.mongodb.org/display/DOCS/Indexes#Indexes-sparse%3Atrue) only present fields
                    </section>

                    <section data-markdown>
                        ## Schema Flexibility

<pre><code class="language-javascript">&gt; db.books.findOne()
{
    _id: 47,
    title: "The Wizard Chase",
<span class="code-highlight inline-block">    type: "series",
    series_title: "The Wizard's Trilogy",
    volume: 2</span>
    // Other fields follow…
}</code></pre>

                        Find all books that are part of a series

<pre><code class="language-javascript">db.books.find({ type: "series" });

db.books.find({ series_title: { $exists: true }});

db.books.find({ volume: { $gt: 0 }});</code></pre>
                    </section>

                    <section data-markdown>
                        ## Index Only Present Fields

                        Documents without these fields will not be indexed.

<pre><code class="language-javascript">db.books.ensureIndex({ series_title: 1 }, { sparse: true });

db.books.ensureIndex({ volume: 1 }, { sparse: true });</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #6

                        Users can recommend at most 10 books
                    </section>

                    <section data-markdown>
                        ## Exercise #6: Solution

<pre><code class="language-javascript">// db.user_recs (track user's remaining and given recommendations)
db.user_recs.insert({
    _id: "bob",
    remaining: 8,
    books: [3, 10]
});

// Record a recommendation if possible
db.user_recs.update(
    { _id: "bob", remaining: { $gt: 0 }, books: { $ne: 4 }},
    { $inc: { remaining: -1 }, $push: { books: 4 }}
});</code></pre>
                    </section>

                    <section data-markdown>
                        ## Exercise #6: Solution

                        * One less unassigned recommendation remaining
                        * Newly-recommended book is now linked

<pre><code class="language-javascript">&gt; db.user_recs.findOne()
{
    _id: "bob",
<span class="code-highlight inline-block">    remaining: 7,
    books: [3, 10, 4]</span>
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #7

                        * Statistic buckets
                            * Each book has a listing page in our application
                            * Record referring website domains for each book
                            * Count each domain independently
                    </section>

                    <section data-markdown>
                        ## Exercise #7: Solution A

<pre><code class="language-javascript">&gt; db.book_refs.findOne()
{   book: 1,
    referrers: [
        { domain: "google.com", count: 4 },
        { domain: "yahoo.com", count: 1 }
    ]
}</code></pre>

<pre><code class="language-javascript">db.book_refs.update(
    { book: 1, "referrers.domain": "google.com" },
    { $inc: { "referrers.$.count": 1 }}
);</code></pre>
                    </section>

                    <section data-markdown>
                        ## Exercise #7: Solution A

                        Update the position of the first matched element.

<pre><code class="language-javascript">db.book_refs.update(
    { book: 1, "referrers.domain": "google.com" },
    { $inc: { <span class="code-highlight">"referrers.$.count"</span>: 1 }}
);</code></pre>

<pre><code class="language-javascript">&gt; db.book_refs.findOne()
{   book: 1,
    referrers: [
<span class="code-highlight inline-block">        { domain: "google.com", count: 5 },</span>
        { domain: "yahoo.com", count: 1 }
    ]
}</code></pre>

                        What if a new referring website is used?
                    </section>

                    <section data-markdown>
                        ## Exercise #7: Solution B

<pre><code class="language-javascript">&gt; db.book_refs.findOne()
{   book: 1,
    referrers: {
        "google_com": 5,
        "yahoo_com": 1
    }
}</code></pre>

<pre><code class="language-javascript">db.book_refs.update(
    { book: 1 },
    { $inc: { "referrers.bing_com": 1 }},
    true
);</code></pre>

                        * Replace dots with underscores for key names
                        * Increment to add a new referring website
                        * Upsert in case this is the book's first referrer
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Sharding
                    </section>

                    <section data-markdown>
                        ## Sharding

                        * Ad-hoc partitioning
                        * Consistent hashing
                            * Amazon DynamoDB
                        * Range based partitioning
                            * Google BigTable
                            * Yahoo! PNUTS
                            * MongoDB
                    </section>

                    <section data-markdown>
                        ## Sharding in MongoDB

                        * Automated management
                        * Range based partitioning
                        * Convert to sharded system with no downtime
                        * Fully consistent
                    </section>

                    <section data-markdown>
                        ## Sharding a Collection

<pre><code class="language-javascript">db.runCommand({ addshard : "shard1.example.com" });

db.runCommand({ enableSharding: "library" });

db.runCommand({
    shardCollection: "library.books",
    key: { _id : 1}
});</code></pre>

                        * Keys range from &minus;&infin; to +&infin;
                        * Ranges are stored as chunks
                    </section>

                    <section data-markdown>
                        ## Sharding Data by Chunks

<pre><code class="language-javascript">db.books.save({ _id: 35, title: "Call of the Wild" });
db.books.save({ _id: 40, title: "Tropic of Cancer" });
db.books.save({ _id: 45, title: "The Jungle" });
db.books.save({ _id: 50, title: "Of Mice and Men" });</code></pre>

                        <div class="node-3">
                            <div class="node">
                                <ul>
                                    <li><code>(&minus;&infin;, +&infin;)</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&rarr;</div>
                            <div class="node">
                                <ul>
                                    <li><code>(&minus;&infin;, 40)</code></li>
                                    <li><code>[40, +&infin;)</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&rarr;</div>
                            <div class="node">
                                <ul>
                                    <li><code>(&minus;&infin;, 40)</code></li>
                                    <li><code>[40, 50)</code></li>
                                    <li><code>[50, +&infin;)</code></li>
                                </ul>
                            </div>
                        </div>

                        Ranges are split into chunks as data is inserted
                    </section>

                    <section data-markdown>
                        ## Adding New Shards

                        <div class="node-3">
                            <div class="node">
                                <span class="label">shard<sub>1</sub></span>
                                <ul>
                                    <li><code>(&minus;&infin;, 40)</code></li>
                                    <li><code>[40, 50)</code></li>
                                    <li><code>[50, 60)</code></li>
                                    <li><code>[60, +&infin;)</code></li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section data-markdown>
                        ## Adding New Shards

<pre><code class="language-javascript">db.runCommand({ addshard : "shard2.example.com" });</code></pre>

                        <div class="node-3">
                            <div class="node">
                                <span class="label">shard<sub>1</sub></span>
                                <ul>
                                    <li><code>(&minus;&infin;, 40)</code></li>
                                    <li>&nbsp;</li>
                                    <li><code>[50, 60)</code></li>
                                    <li>&nbsp;</li>
                                </ul>
                            </div>
                            <div class="node">
                                <span class="label">shard<sub>2</sub></span>
                                <ul>
                                    <li>&nbsp;</li>
                                    <li><code>[40, 50)</code></li>
                                    <li>&nbsp;</li>
                                    <li><code>[60, +&infin;)</code></li>
                                </ul>
                            </div>
                        </div>

                        Chunks are migrated to balance shards
                    </section>

                    <section data-markdown>
                        ## Adding New Shards

<pre><code class="language-javascript">db.runCommand({ addshard : "shard3.example.com" });</code></pre>

                        <div class="node-3">
                            <div class="node">
                                <span class="label">shard<sub>1</sub></span>
                                <ul>
                                    <li><code>(&minus;&infin;, 40)</code></li>
                                    <li>&nbsp;</li>
                                    <li>&nbsp;</li>
                                    <li>&nbsp;</li>
                                </ul>
                            </div>
                            <div class="node">
                                <span class="label">shard<sub>2</sub></span>
                                <ul>
                                    <li>&nbsp;</li>
                                    <li><code>[40, 50)</code></li>
                                    <li>&nbsp;</li>
                                    <li><code>[60, +&infin;)</code></li>
                                </ul>
                            </div>
                            <div class="node">
                                <span class="label">shard<sub>3</sub></span>
                                <ul>
                                    <li>&nbsp;</li>
                                    <li>&nbsp;</li>
                                    <li><code>[50, 60)</code></li>
                                    <li>&nbsp;</li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section>
                        <img src="img/sharding_cache-1.png" alt="sharding_cache-1.png">
                    </section>

                    <section>
                        <img src="img/sharding_cache-2.png" alt="sharding_cache-2.png">
                    </section>

                    <section data-markdown>
                        ## Sharding Components

                        * `mongos`
                        * Config servers
                        * Shards
                            * `mongod`
                            * Replica sets
                    </section>

                    <section data-markdown>
                        ## Sharded Writes

                        * Inserts
                            * Shard key required
                            * Routed
                        * Updates and removes
                            * Shard key optional
                            * May be routed or scattered
                    </section>

                    <section data-markdown>
                        ## Sharded Reads

                        * Queries
                            * By shard key: routed
                            * Without shard key: scatter/gather
                        * Sorted queries
                            * By shard key: routed in order
                            * Without shard key: distributed merge sort
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #8

                        Users can upload images for books

                        <br>
                        <div class="node-3">
                            <div class="node">
                                <span class="label">images</span>
                                <ul>
                                    <li><code>image_id: ???</code></li>
                                    <li><code>data: binary</code></li>
                                </ul>
                            </div>
                        </div>
                        <br>

                        The collection will be sharded by `image_id`.

                        What should `image_id` be?
                    </section>

                    <section data-markdown>
                        ## Exercise #8: Solutions

                        What's the best shard key for our use case?

                        * Auto-increment (ObjectId)
                        * MD5 of data
                        * Time (e.g. month) and MD5
                    </section>

                    <section data-markdown>
                        <img src="img/shard_key-1.png" alt="shard_key-1.png">

                        Right-balanced Access
                    </section>

                    <section data-markdown>
                        <img src="img/shard_key-2.png" alt="shard_key-2.png">

                        Random Access
                    </section>

                    <section data-markdown>
                        <img src="img/shard_key-3.png" alt="shard_key-3.png">

                        Segmented Access
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Summary

                        * Schema design is different in MongoDB.
                        * Basic data design principles apply.
                        * It's about your application.
                        * It's about your data and how it's used.
                        * It's about the entire lifetime of your application.
                    </section>

                    <section data-markdown data-state="final">
                        # Thanks!

                        ### Questions?
                    </section>
                </section>
            </div>
        </div>

        <script src="../vendor/reveal.js/lib/js/head.min.js"></script>
        <script src="../vendor/reveal.js/js/reveal.js"></script>
        <script src="../common/js/reveal.js"></script>
    </body>
</html>
